import os
import asyncio
import fastapi
import socketio
import uvicorn
import cv2
import torch
import yt_dlp
from fastapi.responses import StreamingResponse

from database_manager import DatabaseManager
from prediction_manager import PredictionManager

# Configuration
YOLO_MODEL_NAME = os.getenv('YOLO_MODEL_NAME', 'yolov5m')
INPUT_SOURCE = os.getenv('INPUT_SOURCE', 'https://www.youtube.com/watch?v=FyFAqPHBKiQ')
FRAME_SKIP = int(os.getenv('FRAME_SKIP', '10'))
RESIZE_WIDTH = int(os.getenv('RESIZE_WIDTH', '640'))
NO_MODEL = os.getenv('NO_MODEL', '0').lower() in ('1', 'true', 'yes')

# App
app = fastapi.FastAPI()
sio = socketio.AsyncServer(async_mode='asgi', cors_allowed_origins='*')
socket_app = socketio.ASGIApp(sio, socketio_path='/ws')
app.mount('/ws', socket_app)

# Globals
latest_frame_for_streaming = None
last_person_count = 0
last_prediction = 0
current_input_source = INPUT_SOURCE

# Model load
if NO_MODEL:
    print('‚ö†Ô∏è NO_MODEL enabled; skipping model load')
    model = None
else:
    print('üß† Loading YOLO model...')
    model = torch.hub.load('ultralytics/yolov5', YOLO_MODEL_NAME, pretrained=True, trust_repo=True)
    model.classes = [0]
    model.conf = 0.5
    print('‚úÖ Model loaded')

db_manager = DatabaseManager()
prediction_manager = PredictionManager()


async def frame_generator():
    """Yield MJPEG frames built from latest_frame_for_streaming."""
    global latest_frame_for_streaming
    while True:
        if latest_frame_for_streaming is not None:
            flag, encoded = cv2.imencode('.jpg', latest_frame_for_streaming)
            if flag:
                yield (b'--frame\r\n' b'Content-Type: image/jpeg\r\n\r\n' + bytearray(encoded) + b'\r\n')
        await asyncio.sleep(0.03)


@app.get('/video_feed')
async def video_feed():
    return StreamingResponse(frame_generator(), media_type='multipart/x-mixed-replace;boundary=frame')


async def main_processing_loop():
    global latest_frame_for_streaming, last_person_count, last_prediction

    # Open capture
    cap = None
    try:
        if isinstance(INPUT_SOURCE, str) and ('youtube.com' in INPUT_SOURCE or 'youtu.be' in INPUT_SOURCE):
            print(f'üì° Extracting stream from {INPUT_SOURCE}...')
            with yt_dlp.YoutubeDL({'format': 'best', 'noplaylist': True}) as ydl:
                info = ydl.extract_info(INPUT_SOURCE, download=False)
                stream_url = info.get('url')
            cap = cv2.VideoCapture(stream_url, cv2.CAP_FFMPEG)
        else:
            cap = cv2.VideoCapture(INPUT_SOURCE)
    except Exception as e:
        print('‚ùå Failed to open source:', e)
        return

    if not cap or not cap.isOpened():
        print('‚ùå Capture not opened')
        return

    frame_counter = 0
    while True:
        try:
            success, frame = cap.read()
            if not success:
                await asyncio.sleep(1)
                continue

            h, w = frame.shape[:2]
            scale = RESIZE_WIDTH / w
            resized = cv2.resize(frame, (int(w * scale), int(h * scale)))

            frame_counter += 1
            if frame_counter % FRAME_SKIP == 0:
                if model is None:
                    person_count = 0
                    pred = 0
                else:
                    results = model(resized)
                    person_count = len(results.xyxy[0])
                    try:
                        db_manager.save_crowd_data(person_count)
                    except Exception as e:
                        print('DB save error:', e)
                    pred = prediction_manager.get_future_prediction()

                last_person_count = person_count
                last_prediction = pred
                await sio.emit('broadcast_data', {'count': person_count, 'prediction': pred})

                if model is not None:
                    results.render()
                    latest_frame_for_streaming = results.ims[0].copy()
                else:
                    latest_frame_for_streaming = resized
            else:
                latest_frame_for_streaming = resized

            await asyncio.sleep(0.01)
        except asyncio.CancelledError:
            break
        except Exception as e:
            print('Error in main loop:', e)
            await asyncio.sleep(1)


@app.on_event('startup')
async def startup_event():
    print('üöÄ Starting processing loop')
    asyncio.create_task(main_processing_loop())


@sio.event
async def connect(sid, environ):
    print('Client connected', sid)
    try:
        await sio.emit('init', {'source': current_input_source, 'last_count': last_person_count, 'last_prediction': last_prediction}, to=sid)
    except Exception as e:
        print('failed init:', e)


@sio.event
async def disconnect(sid):
    print('Client disconnected', sid)


if __name__ == '__main__':
    uvicorn.run('server:app', host='0.0.0.0', port=8000)
